use std::{
    pin::Pin,
    time::{Duration, Instant},
};

use anyhow::Result;
use futures_util::StreamExt;
use librespot::{
    connect::spirc::Spirc,
    core::{
        config::{ConnectConfig, SessionConfig},
        session::Session,
    },
    playback::{
        config::{AudioFormat, PlayerConfig, VolumeCtrl},
        mixer::{self, MixerConfig},
        player::Player,
    },
};
use sha1::{Digest, Sha1};
use tonic::transport::Channel;

use crate::pb::spotify_remote_client::SpotifyRemoteClient;

const RECONNECT_RATE_LIMIT_WINDOW: Duration = Duration::from_secs(600);
const RECONNECT_RATE_LIMIT: usize = 5;

#[derive(Debug)]
pub struct Transmitter {
    grpc_client: SpotifyRemoteClient<Channel>,
    device_name: String,
}

impl Transmitter {
    pub async fn new(receiver_addr: String, device_name: String) -> Result<Self> {
        let grpc_client = SpotifyRemoteClient::connect(receiver_addr).await?;
        Ok(Self {
            grpc_client,
            device_name,
        })
    }

    pub async fn run(self) -> Result<()> {
        let format = AudioFormat::default();
        let mixer = mixer::find(None).unwrap();
        let mixer_config = MixerConfig {
            volume_ctrl: VolumeCtrl::Log(VolumeCtrl::DEFAULT_DB_RANGE),
            ..Default::default()
        };

        let connect_config = ConnectConfig {
            name: self.device_name.clone(),
            initial_volume: None,
            has_volume_ctrl: true,
            autoplay: true,
            device_type: Default::default(),
        };

        let session_config = SessionConfig {
            device_id: device_id(&connect_config.name),
            ..Default::default()
        };

        // TODO: or bitrate 360
        let player_config = PlayerConfig::default();

        // state stuff
        let mut last_credentials = None;
        let mut spirc: Option<Spirc> = None;
        let mut spirc_task: Option<Pin<_>> = None;
        let mut auto_connect_times: Vec<Instant> = vec![];
        let mut connecting = false;
        //

        let device_id = session_config.device_id.clone();
        let mut discovery = librespot::discovery::Discovery::builder(device_id)
            .name(connect_config.name.clone())
            .launch()?;

        let mut session: Option<Session> = None;

        tracing::debug!("Starting discovery loop");

        loop {
            tracing::debug!("discovery loop");
            tokio::select! {
                credentials = discovery.next() => {
                    tracing::debug!("discovery next");
                    match credentials {
                        Some(credentials) => {
                            tracing::debug!(?credentials, "got creds");
                            last_credentials = Some(credentials.clone());
                            auto_connect_times.clear();

                            if let Some(spirc) = spirc.take() {
                                spirc.shutdown()
                            }
                            if let Some(spirc_task) = spirc_task.take() {
                                // Continue shutdown in its own task
                                tokio::spawn(spirc_task);
                            }

                            let (sesh, _reusable_creds) = Session::connect(session_config.clone(), credentials, None, false).await.unwrap();
                            session = Some(sesh);

                            connecting = true;
                        },
                        None => {
                            anyhow::bail!("Discovery stopped unexpectedly");
                        }
                    }
                },
                _ = async {}, if connecting && last_credentials.is_some() => {
                    tracing::debug!("connecting");

                    let mixer_config = mixer_config.clone();
                    let mixer = (mixer)(mixer_config);
                    let player_config = player_config.clone();
                    let connect_config = connect_config.clone();

                    let soft_volume = mixer.get_soft_volume();
                    let format = format;

                    let mut bs = crate::buf_sink::BufSink::new(format);
                    let audio_rx = bs.rx();
                    let (player, _) = Player::new(player_config, session.as_ref().cloned().unwrap(), soft_volume, move || {
                        Box::new(bs)
                    });

                    // seems like spirc controls the player and exposes a commands queue
                    // and manages the subscription?
                    let (spirc_, spirc_task_) = Spirc::new(connect_config, session.as_ref().cloned().unwrap(), player, mixer);
                    spirc = Some(spirc_);
                    spirc_task = Some(Box::pin(spirc_task_));

                    connecting = false;

                    // TODO: doesnt respond to ctrl-c anymore
                    // TODO: starts at 0 volume

                    tracing::debug!("piping");
                    // spawn a task to pipe the audio channel into the grpc client
                    let mut client = self.grpc_client.clone();
                    let name = self.device_name.clone();
                    let _jh = tokio::task::spawn(async move {
                        let name = name;
                        tracing::debug!(?name, "starting audio stream");
                        let stream = futures_util::stream::iter(audio_rx.into_iter().map(move |buf| {
                            // tracing::trace!(?name, "sending audio chunk");
                            let name = name.clone();
                            crate::pb::AudioChunk{ id: name.clone(), data: buf }
                        }));
                        let res = client.send_audio(stream).await;
                        tracing::info!(?res, "stream finished")
                    });
                },
                _ = async {
                    if let Some(task) = spirc_task.as_mut() {
                        task.await;
                    }
                }, if spirc_task.is_some() && !connecting => {
                    spirc_task = None;

                    tracing::warn!("Spirc shut down unexpectedly");

                    let mut reconnect_exceeds_rate_limit = || {
                        auto_connect_times.retain(|&t| t.elapsed() < RECONNECT_RATE_LIMIT_WINDOW);
                        auto_connect_times.len() > RECONNECT_RATE_LIMIT
                    };

                    match last_credentials.clone() {
                        Some(_) if !reconnect_exceeds_rate_limit() => {
                            auto_connect_times.push(Instant::now());
                            connecting = true;
                        },
                        _ => {
                            anyhow::bail!("Spirc shut down too often. Not reconnecting automatically.");
                        },
                    }
                },
                _ = tokio::signal::ctrl_c() => {
                    break;
                },
                else => break,
            }
        }

        tracing::info!("Gracefully shutting down");

        // Shutdown spirc if necessary
        if let Some(spirc) = spirc {
            spirc.shutdown();

            if let Some(mut spirc_task) = spirc_task {
                tokio::select! {
                    _ = tokio::signal::ctrl_c() => (),
                    _ = spirc_task.as_mut() => (),
                    else => (),
                }
            }
        }

        Ok(())
    }
}

fn device_id(name: &str) -> String {
    hex::encode(Sha1::digest(name.as_bytes()))
}
